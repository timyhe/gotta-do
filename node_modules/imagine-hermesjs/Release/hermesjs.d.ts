declare namespace Imagine.Hermes {
    /** interface for describing a relational table in javascript */
    interface IHermesTable {
        /** columns of the table */
        columns: string[];
        /** array of rows, with row values coresponding to the columns array above */
        rows: any[][];
    }
    /** interface for wrapping up a Hermes text response, includes the mimetype */
    interface IHermesTextResponse {
        /** mimeType of text request, fetched from the HTTP response ContentType */
        mimeType: string;
        /** text body */
        text: string;
    }
    /** hashtable used to provide named parameter values to stored procedures  */
    interface IHermesFunctionParams {
        [parameter: string]: any;
    }
    /** represents a Hermes key/value pair */
    interface IHermesItem<T extends object = object> {
        /** key used to reference item */
        key: string;
        /** optional orderIndex, handle with care */
        orderIndex?: number;
        /** object to save, must be non-primative JavaScript object */
        data: T;
    }
    /** generic Hermes response  */
    interface IHermesResponse<T> {
        /** actual response object */
        body: T;
        /** boolean indicating if the operation was a success or not */
        success: boolean;
        /** postgres exception code */
        pexCode: string;
        /** error message if operation fails, should be 'success' if operation is successful */
        message: string;
        /** duration operation took to complete */
        duration: number;
        /** a count of the number of results, used by most methods that return an array.
         * if paging is used, this is the total count of the query, not the size of the page
         */
        results: number;
    }
    /** is deprecated, use Imagine.Resty instead */
    interface IEndpointConfig extends Imagine.Resty.IEndpointConfig {
    }
}
declare namespace Imagine.Resty {
    interface IEndpointConfig {
        /** protocol */
        protocol?: string;
        /** hostname / IP address */
        hostname?: string;
        /** port number */
        port?: number;
    }
    interface IRestyConfig {
        /** endpoint configuration  */
        endpoint: IEndpointConfig;
        /** GlobalFetch compatible function to use instead of browser supplied window.fetch  */
        fetchOverride?: GlobalFetch;
        /** JSON serializer to use instead of JSON */
        jsonOverride?: JSON;
        /** success callback to call on the successful completion of all requests */
        successCallback?: () => void;
        /** error callback to call on the failure of all requests */
        errorCallback?: () => void;
        /** default headers to include in every request */
        defaultHeaders?: any;
    }
    interface IRestyRequestConfig extends RequestInit {
        url: string;
    }
}

declare namespace Imagine.Resty {
    const Method: {
        GET: string;
        POST: string;
        PUT: string;
        DELETE: string;
        PATCH: string;
        HEAD: string;
        OPTIONS: string;
        CONNECT: string;
    };
    function getHostUrl(endpoint: IEndpointConfig): string;
    function sendRequest(request: IRestyRequestConfig, fetchFunction: (input: RequestInfo, init?: RequestInit) => Promise<Response>, jsonOverride?: JSON, successCallback?: () => void, errorCallback?: (err: any) => void): Promise<any>;
    /** checks the provided headers to see if the response should be considered a JSON response or not */
    function isJson(headers: Headers): boolean;
    /** adds headers and stringifies the body, making ready to send */
    function formatRequest(request: IRestyRequestConfig, jsonOverride?: JSON, headers?: any): IRestyRequestConfig;
    /** base level REST layer class, implementing a basic REST data layer via fetch */
    class RestyLayer {
        protected config: IRestyConfig;
        protected DEFAULT_PROTOCOL: string;
        protected DEFAULT_HOSTNAME: string;
        protected DEFAULT_PORT: number;
        protected DEFAULT_HEADERS: {
            "Content-type": string;
            "Accept": string;
        };
        constructor(config: IRestyConfig);
        protected initialize: (config?: IRestyConfig) => void;
        setCallback: (success: () => void, error: () => void) => void;
        /** returns the protocol, hostname, and port combined as a base url */
        readonly baseUrl: string;
        /** checks the provided headers to see if the response should be considered a JSON response or not */
        protected isJson: (headers: Headers) => boolean;
        /**
         * formats the provided IHermesRequestConfig with formatRequest, then checks the local fetchInject an uses it if available, falling through to window.fetch
         * handles common errors and parsing of json / text responses
         */
        protected sendRequest: (request: IRestyRequestConfig) => Promise<any>;
        /** adds headers and stringifies the body, making ready to send */
        protected formatRequest: (request: IRestyRequestConfig, headers?: any) => IRestyRequestConfig;
        /** returns the specially provided fetch override method, or the default global one if no override specified */
        protected readonly Fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
        protected readonly JSON: JSON;
    }
}

declare namespace Imagine.Hermes {
    type StringOrPromise = string | Promise<string>;
    /** result of the loadFiles method, using the IConfigSettings.name field as indexer */
    interface IConfigSettingsTable {
        [name: string]: IConfigSettings;
    }
    interface IConfigSettings {
        /** name to save this config under */
        name: string;
        /** list of locations to load this config item from */
        location?: StringOrPromise | StringOrPromise[];
        /** value to use, will skip any attempt to load from provided locations */
        value?: any;
        /** default value to use if all sources fail to load */
        default?: any;
    }
    class ConfigLoader {
        verboseLogging: boolean;
        readonly version: string;
        constructor(verboseLogging?: boolean);
        /** loads an array of IConfigSettings into an IConfigSettingsTable via window.fetch */
        loadFiles: (settings: IConfigSettings[]) => Promise<IConfigSettingsTable>;
        private loadConfigSetting;
        /** attempt to load an array of urls, returning the first successful response, starting at 0 */
        private loadFilesFallthrough;
        /** attempt to load an array of urls, returning the first successful response */
        private loadFileFallthrough;
        /** uses window.fetch to load a given URL */
        loadFile: (f: string) => Promise<any>;
        /** merges IConfigSettingsTable merge into IConfigSettingsTable target, and returns target */
        mergeTable: (target: IConfigSettingsTable, merge: IConfigSettingsTable) => IConfigSettingsTable;
    }
}

declare namespace Imagine.Hermes {
    class HermesRest {
        /** turns an IEndpointConfig into the root URL of Hermes API, defaults to http protocol if unspecified */
        static getHostUrl: (endpoint: Resty.IEndpointConfig) => string;
        /** gets a version number */
        static getVersionRequest: (endpoint: Resty.IEndpointConfig) => Resty.IRestyRequestConfig;
        static getIPAddressRequest: (endpoint: Resty.IEndpointConfig) => Resty.IRestyRequestConfig;
        static getDatabasesRequest: (endpoint: Resty.IEndpointConfig) => Resty.IRestyRequestConfig;
        static createDatabaseRequest: (endpoint: Resty.IEndpointConfig, dbName: string) => Resty.IRestyRequestConfig;
        static deleteDatabaseRequest: (endpoint: Resty.IEndpointConfig, dbName: string) => Resty.IRestyRequestConfig;
        static getTablesRequest: (endpoint: Resty.IEndpointConfig, dbName: string) => Resty.IRestyRequestConfig;
        static createTableRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, useOrderIndex: boolean) => Resty.IRestyRequestConfig;
        static getTableKeysRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string) => Resty.IRestyRequestConfig;
        static deleteTableRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string) => Resty.IRestyRequestConfig;
        static getTableItemsRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string) => Resty.IRestyRequestConfig;
        static insertItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, item: IHermesItem<object>) => Resty.IRestyRequestConfig;
        static upsertItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, item: IHermesItem<object>) => Resty.IRestyRequestConfig;
        static getItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, key: string) => Resty.IRestyRequestConfig;
        static deleteItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, key: string) => Resty.IRestyRequestConfig;
        static updateItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, key: string, item: any) => Resty.IRestyRequestConfig;
        static bulkInsertItemsRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, items: IHermesItem<object>[]) => Resty.IRestyRequestConfig;
        static bulkUpsertItemsRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, items: IHermesItem<object>[]) => Resty.IRestyRequestConfig;
        static bulkDeleteItemsRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, keys: string[]) => Resty.IRestyRequestConfig;
        static getPageRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, pageSize: number, startKey?: string) => Resty.IRestyRequestConfig;
        static dynamicQueryRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, pageNum: number, pageSize: number, whereInject: string, orderbyInject: string) => Resty.IRestyRequestConfig;
        static storedProcedureRequest: (endpoint: Resty.IEndpointConfig, dbName: string, procName: string, queryType: string, params: IHermesFunctionParams) => Resty.IRestyRequestConfig;
        static getSpecialKeysRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string) => {
            method: string;
            url: string;
        };
        static getSpecialItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, tableName: string, key: string) => {
            method: string;
            url: string;
        };
        static deleteImageRequest: (endpoint: Resty.IEndpointConfig, dbName: string, key: string) => Resty.IRestyRequestConfig;
        static insertTextItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, key: string, data: string, mimeType?: string) => Resty.IRestyRequestConfig;
        static upsertTextItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, key: string, data: string, mimeType?: string) => Resty.IRestyRequestConfig;
        static deleteTextItemRequest: (endpoint: Resty.IEndpointConfig, dbName: string, key: string) => Resty.IRestyRequestConfig;
        static getTextUrl: (endpoint: Resty.IEndpointConfig, dbName: string, fileName: string) => string;
        static getFileUrl: (endpoint: Resty.IEndpointConfig, dbName: string, fileName: string) => string;
        static getImageUrl: (endpoint: Resty.IEndpointConfig, dbName: string, fileName: string) => string;
    }
    class HermesDataLayer extends Imagine.Resty.RestyLayer {
        constructor(config: Imagine.Resty.IRestyConfig);
        /** need to manually parse string as Hermes returns responses as text/plain and
         * default ImagineResty.sendRequest will return that as a string
         */
        private sendHermesRequest;
        getVersion: () => Promise<IHermesResponse<number>>;
        getIPAddress: () => Promise<IHermesResponse<string>>;
        getDatabases: () => Promise<IHermesResponse<string[]>>;
        createDatabase: (dbName: string) => Promise<IHermesResponse<any>>;
        deleteDatabase: (dbName: string) => Promise<IHermesResponse<any>>;
        getTables: (dbName: string) => Promise<IHermesResponse<string[]>>;
        createTable: (dbName: string, tableName: string, useOrderIndex?: boolean) => Promise<IHermesResponse<any>>;
        getTableKeys: (dbName: string, tableName: string) => Promise<IHermesResponse<string[]>>;
        deleteTable: (dbName: string, tableName: string) => Promise<IHermesResponse<any>>;
        getTableItems: <T extends object = object>(dbName: string, tableName: string) => Promise<IHermesResponse<IHermesItem<T>[]>>;
        insertItem: (dbName: string, tableName: string, item: IHermesItem<object>) => Promise<IHermesResponse<any>>;
        upsertItem: (dbName: string, tableName: string, item: IHermesItem<object>) => Promise<IHermesResponse<any>>;
        getItem: <T extends object = object>(dbName: string, tableName: string, key: string) => Promise<IHermesResponse<IHermesItem<T>>>;
        deleteItem: (dbName: string, tableName: string, key: string) => Promise<IHermesResponse<any>>;
        updateItem: (dbName: string, tableName: string, key: string, item: any) => Promise<IHermesResponse<any>>;
        bulkInsertItems: (dbName: string, tableName: string, items: IHermesItem<object>[]) => Promise<IHermesResponse<any>>;
        bulkUpsertItems: (dbName: string, tableName: string, items: IHermesItem<object>[]) => Promise<IHermesResponse<any>>;
        bulkDeleteItems: (dbName: string, tableName: string, keys: string[]) => Promise<IHermesResponse<any>>;
        getPage: <T extends object = object>(dbName: string, tableName: string, pageSize: number, startKey?: string) => Promise<IHermesResponse<IHermesItem<object>[]>>;
        dynamicQuery: <T extends object = object>(dbName: string, tableName: string, pageNum: number, pageSize: number, whereInject: string, orderbyInject: string) => Promise<IHermesResponse<IHermesItem<object>[]>>;
        storedProcedureQuery: (dbName: string, procName: string, params: IHermesFunctionParams) => Promise<IHermesResponse<IHermesTable>>;
        storedProcedureScalar: (dbName: string, procName: string, params: IHermesFunctionParams) => Promise<IHermesResponse<any>>;
        storedProcedureNonQuery: (dbName: string, procName: string, params: IHermesFunctionParams) => Promise<IHermesResponse<void>>;
        getImageKeys: (dbName: string) => Promise<any>;
        /** returns a formatted URL for requesting an image from the Hermes thumbnail table */
        getImageUrl: (dbName: string, imageName: string) => string;
        deleteImage: (dbName: string, key: string) => Promise<any>;
        /** returns a formatted URL for requesting a text file from the Hermes text table */
        getTextUrl: (dbName: string, fileName: string) => string;
        getTextKeys: (dbName: string) => Promise<any>;
        getTextItem: (dbName: string, key: string) => Promise<IHermesTextResponse>;
        insertTextItem: (dbName: string, key: string, data: string, mimeType?: string) => Promise<any>;
        upsertTextItem: (dbName: string, key: string, data: string, mimeType?: string) => Promise<any>;
        deleteTextItem: (dbName: string, key: string) => Promise<any>;
        /** returns a formatted URL for requesting a file from the Hermes file table */
        getFileUrl: (dbName: string, fileName: string) => string;
        getFileKeys: (dbName: string) => Promise<any>;
    }
}
